[["index.html", "Naslund Chapter 1 Analysis Chapter 1 Sampling scheme 1.1 Dissolved oxygen 1.2 Temperature 1.3 Residence time calculation", " Naslund Chapter 1 Analysis Laura Naslund 2023-01-18 Chapter 1 Sampling scheme We sampled 4 sites over at least one 24 hr period. We installed 25 ebullition traps across 5 transects in each impoundment. Every 3 hours, we recorded the volume of gas accumulated in each ebullition trap and took a diffusive flux measurement immediately adjacent to 10 if the ebullition traps across the impoundment. To determine impoundment area, I digitized the impoundments using high resolution (0.5 ft) orthoimagery captured during the leaf off period. Pick has a beaver dam on the inlet stream and I delineated only to the beaver dam. Site Area (km2) Max Depth (m) Mean Depth (m) Residence Time (days) Dates Sampled Deans 0.0041 3.52 2.03 46 8/16/22 - 8/17/228/30/22 - 8/31/22 Sister 3 0.0012 2.27 1.25 20 8/22/22 - 8/23/22 Catfish 0.0018 1.98 0.80 19 9/06/22 - 9/07/229/18/22 - 9/19/22 Pick 0.0077 3.80 1.58 45 8/22/22 - 8/23/22 1.1 Dissolved oxygen We recorded dissolved oxygen every 15 minutes 0.25 m below the surface in every impoundment. From 6/20/22 to 7/13/22, we also recorded dissolved oxygen 0.1m from the bottom of Pick in the deepest location in the impoundment. Because dissolved oxygen was consistently 0 mg/L, we reallocated our oxygen sensors and installed both a top and bottom DO sensor in Sister 3. 1.1.1 Deans 1.1.2 Catfish 1.1.3 Sister 3 1.1.4 Pick 1.1.5 All impoundments top DO 1.2 Temperature 1.2.1 Deans 1.2.2 Catfish 1.2.3 Sister 3 1.2.4 Pick 1.3 Residence time calculation I took a point estimate of discharge from the ponds while sampling, but these discharge values gave unrealistic residence times. I instead calculated discharge from a regional regression equation using average annual precipitation and watershed area (Gotvald et al.Â 2017). "],["diffusive-emissions.html", "Chapter 2 Diffusive emissions 2.1 Deans Cloud Comparison 2.2 Deans 8/16/22-8/17/22 2.3 Deans 8/30/22-8/31/22 2.4 Catfish Cloud Comparison 2.5 Catfish 9/6/22-9/7/22 2.6 Catfish 9/18/22-9/19/22 2.7 Pick 9/13/22- 9/14/22 2.8 Sister3 8/22/22-8/23/22", " Chapter 2 Diffusive emissions 2.1 Deans Cloud Comparison ## Warning: package &#39;vembedr&#39; was built under R version 4.2.2 ## ## Attaching package: &#39;vembedr&#39; ## The following object is masked from &#39;package:lubridate&#39;: ## ## hms 2.2 Deans 8/16/22-8/17/22 2.3 Deans 8/30/22-8/31/22 2.4 Catfish Cloud Comparison 2.5 Catfish 9/6/22-9/7/22 2.6 Catfish 9/18/22-9/19/22 2.7 Pick 9/13/22- 9/14/22 2.8 Sister3 8/22/22-8/23/22 "],["ebullition.html", "Chapter 3 Ebullition 3.1 Deans 8/16/22-8/17/22 3.2 Deans 8/30/22-8/31/22 3.3 Catfish 9/06/22-9/07/22 (Clouds cleared by 9AM, sparce clouds until ~ 4, cleared around 7, overcast the next morning) 3.4 Catfish 9/18/22-9/19/22 (cloudless until 12-3 pretty cloudy) 3.5 Pick 9/13/22-9/14/22 3.6 Sister 3 8/22/22-8/23/22", " Chapter 3 Ebullition 7.8% of gas volume observations indicated a decline in gas volume from one time period to the next. Most of these observations occurred at night and in the pond covered with Wolffia. I set all negative observations of volume greater than -0.5mL change equal to 0. All other negative gas volume observations (&lt;1%) were treated as missing data. Because there was insufficient gas volume to measure CH4 concentration at every time-point, I used the average CH4 concentration measured from ebullition in a sampling event to calculate ebullition for the following figures. 3.1 Deans 8/16/22-8/17/22 3.2 Deans 8/30/22-8/31/22 3.3 Catfish 9/06/22-9/07/22 (Clouds cleared by 9AM, sparce clouds until ~ 4, cleared around 7, overcast the next morning) 3.4 Catfish 9/18/22-9/19/22 (cloudless until 12-3 pretty cloudy) 3.5 Pick 9/13/22-9/14/22 3.6 Sister 3 8/22/22-8/23/22 tm_shape(sister3)+ tm_polygons(col = &quot;white&quot;)+ tm_shape(sister3_pts_22_eb, bbox = st_bbox(catfish) %&gt;% st_as_sfc())+ tm_dots(&quot;ch4_eb_g_m2_hr&quot;, size = 0.5, shape = 21, palette = &quot;-RdYlBu&quot;, midpoint = NA, title = &quot;CH4 flux (g/m2/hr)&quot;)+ tm_layout(scale = 1.5, legend.outside = T)+ tm_facets(by = &quot;trip_wr&quot;, free.coords = F, inside.original.bbox = T) ## Warning: Removed 99 rows containing non-finite values (stat_bin). "],["simple-kriging-just-in-space.html", "Chapter 4 Simple kriging just in space", " Chapter 4 Simple kriging just in space test_data &lt;- pick_pts_13 %&gt;% filter(trip == 2) # Detrend before normal score # create x y trend model and pull residuals to krige test_data$x &lt;- st_coordinates(test_data) %&gt;% as.data.frame() %&gt;% pull(X) test_data$y &lt;- st_coordinates(test_data) %&gt;% as.data.frame() %&gt;% pull(Y) func_trend &lt;- as.formula(flux_co2_g_hr ~ x + y) lm_trend &lt;- lm(func_trend, data = test_data) summary(lm_trend) ## ## Call: ## lm(formula = func_trend, data = test_data) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.52583 -0.10096 -0.02899 0.21436 0.41754 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.815e+04 3.024e+04 1.593 0.1457 ## x -1.999e-02 7.032e-03 -2.842 0.0193 * ## y -1.130e-02 7.539e-03 -1.499 0.1680 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3229 on 9 degrees of freedom ## Multiple R-squared: 0.7654, Adjusted R-squared: 0.7132 ## F-statistic: 14.68 on 2 and 9 DF, p-value: 0.001468 test_data$resid_co2_g_hr &lt;- residuals(lm_trend) hist(test_data$resid_co2_g_hr) # function to return table with normal scores and original values to use for backtransform later nscore &lt;- function(x) { nscore &lt;- qqnorm(x, plot.it = FALSE)$x # normal score trn.table &lt;- data.frame(x=sort(x),nscore=sort(nscore)) return (trn.table) } # quantile-quantile normal score transform data test_data$resid_norm_co2_g_hr &lt;- qqnorm(test_data$resid_co2_g_hr, plot.it = F)$x nscore.tab &lt;- nscore(test_data$resid_co2_g_hr) plot(x~nscore, data=nscore.tab) plot(ecdf(test_data$resid_co2_g_hr)) plot(ecdf(test_data$resid_norm_co2_g_hr)) hist(test_data$resid_co2_g_hr) hist(test_data$resid_norm_co2_g_hr) mapview(test_data, zcol = &quot;resid_norm_co2_g_hr&quot;) # create isotropic variogram # width = lag distance (approximately minimum non zero data spacing) # cutoff = number of lags * lag distance (number of lags = 1/2 major axis/lag distance) # think about how cutoff and width parameters are impacting variogram calculation var.norm.iso &lt;- variogram(resid_norm_co2_g_hr~1, test_data ,cutoff = 70 ,width = 14) var.norm.th.iso &lt;- vgm(psill = 1, &quot;Exp&quot;, range = 17) # no nugget # plot theoretical with experimental variogram vm.norm.sim &lt;- variogramLine(var.norm.th.iso,maxdist=100,min=0.0001,n=100, covariance=FALSE) plot(var.norm.iso$dist,var.norm.iso$gamma, xlim = c(0,100)) lines(vm.norm.sim$dist,vm.norm.sim$gamma,col=&quot;blue&quot;) # create anisotropic variogram (doesn&#39;t appear to be enough data to do this/not well supported with residuals of gaussian transformed model) var.norm.045 = variogram(resid_norm_co2_g_hr~1,test_data,cutoff = 70,width =14,alpha = 45.0,tol.hor=22.5) # 045 directional var.norm.135 = variogram(resid_norm_co2_g_hr~1,test_data,cutoff = 70,width =14,alpha = 135.0,tol.hor=22.5) # 135 directional var.norm.th.ani&lt;- vgm(psill = 1, &quot;Exp&quot;, 17, anis = c(135, 0.5)) # plot theoretical anisotropic variograms with experimental variograms unit_vector = c(sin(45*pi/180),sin(45*pi/180),0) # unit vector for 035 azimuth vm.norm.sim.an.45 &lt;- variogramLine(var.norm.th.ani, maxdist=100,min=0.0001,n=100, covariance=FALSE, dir=unit_vector) unit_vector = c(sin(45*pi/180),-sin(45*pi/180),0) # unit vector for 035 azimuth vm.norm.sim.an.135 &lt;- variogramLine(var.norm.th.ani, maxdist=100,min=0.0001,n=100, covariance=FALSE, dir=unit_vector) plot(var.norm.135$dist, var.norm.135$gamma, col = &quot;green&quot;) points(var.norm.045$dist, var.norm.045$gamma, col = &quot;red&quot;) lines(vm.norm.sim.an.45$dist, vm.norm.sim.an.45$gamma, col =&quot;red&quot;) lines(vm.norm.sim.an.135$dist, vm.norm.sim.an.135$gamma, col =&quot;green&quot;) # create interpolation grid grid &lt;- st_as_stars(st_bbox(pick), dx = 1, dy = 1) grid &lt;- grid[pick] # ordinary kriging (assumption of stationarity of the mean is relaxed, mean is estimated locally) co2.kriged = krige(resid_norm_co2_g_hr~1, test_data, grid, model = var.norm.th.iso,maxdist = Inf,nmin = 0,omax=Inf) ## Warning in predict.gstat(g, newdata = newdata, block = block, nsim = nsim, : NAs ## introduced by coercion to integer range ## [using ordinary kriging] # simple kriging (mean is stationary) co2.kriged.sk = krige(resid_norm_co2_g_hr~1, test_data, grid, model = var.norm.th.iso,maxdist = Inf,nmin = 0,omax=Inf, beta = mean(test_data$resid_norm_co2_g_hr)) ## Warning in predict.gstat(g, newdata = newdata, block = block, nsim = nsim, : NAs ## introduced by coercion to integer range ## [using simple kriging] # ordinary and simple kriging (yield very similar results in this example) range(co2.kriged$var1.pred, na.rm = T) ## [1] -1.676307 1.670763 range(co2.kriged.sk$var1.pred, na.rm = T) ## [1] -1.675864 1.670890 plot(co2.kriged) # add back in the trend to the kriged residuals co2.kriged$trend &lt;- predict(co2.kriged, lm_trend) co2.kriged$detrended.norm &lt;- co2.kriged$trend + co2.kriged$var1.pred plot(co2.kriged[4]) range(co2.kriged[4]$detrended.norm, na.rm = T) ## [1] -1.439475 2.145037 hist(co2.kriged[4]$detrended.norm) # backtransform normal scores # based on the gslib documentation, it looks like what you need to do is for each point interpolate between points in the normal score table and use an extrapolation function (possibly linear?) for points beyond the range above.max.lm &lt;- lm(x~nscore, data=nscore.tab[(nrow(nscore.tab)-1):nrow(nscore.tab),]) above.max.func &lt;- function(x){ coefficients(above.max.lm)[[1]] + (coefficients(above.max.lm)[[2]]*x) } below.min.lm &lt;- lm(x~nscore, data=nscore.tab[1:2,]) below.min.func &lt;- function(x){ coefficients(below.min.lm)[[1]] + (coefficients(below.min.lm)[[2]]*x) } interpolate &lt;- approxfun(x=nscore.tab$nscore, y=nscore.tab$x) backtr &lt;- function(x){ if(is.na(x)){ return(NA) } if(x&gt;max(nscore.tab$nscore)){ return(above.max.func(x)) } if(x&lt;min(nscore.tab$nscore)){ return(below.min.func(x)) } else{ return(interpolate(x)) } } co2.kriged$backtransformed &lt;- apply(co2.kriged$detrended.norm, 1:2, backtr) mapview(co2.kriged[5])+ mapview(test_data, zcol = &quot;flux_co2_g_hr&quot;, col.region=viridis::viridis_pal(option = &quot;A&quot;)) # Sequential Gaussian simulation with isotropic variogram using simple kriging (but ordinary kriging also run) # Ortiz 2020 https://qspace.library.queensu.ca/bitstream/handle/1974/28538/2020-01-Ortiz-Simulation.pdf?sequence=2 indicates that you shouldn&#39;t use ordinary kriging in sequential gaussian simulation. The krige function I think allows you to use ordinary kriging and it looks like it might be trying to estimate beta within the function. co2.kriged.sim = krige(resid_norm_co2_g_hr~1, test_data, grid, model = var.norm.th.iso,maxdist = Inf,nmin = 0,omax=Inf, indicators=FALSE, nsim=4, nmax=100) # will take a second to run ## Warning in predict.gstat(g, newdata = newdata, block = block, nsim = nsim, : NAs ## introduced by coercion to integer range ## drawing 4 GLS realisations of beta... ## [using conditional Gaussian simulation] co2.kriged.sim.sk = krige(resid_norm_co2_g_hr~1, test_data, grid, model = var.norm.th.iso,maxdist = Inf,nmin = 0,omax=Inf, indicators=FALSE, nsim=4, nmax=100, beta = 0) # will take a second to run # mean should be zero after gaussian transformation # I don&#39;t know if beta is required here ## Warning in predict.gstat(g, newdata = newdata, block = block, nsim = nsim, : NAs ## introduced by coercion to integer range ## [using conditional Gaussian simulation] co2.kriged.sim.sk$trend &lt;- predict(co2.kriged.sim.sk, lm_trend) co2.kriged.sim.sk$detrended.norm &lt;- co2.kriged.sim.sk$trend + co2.kriged.sim.sk$var1 plot(co2.kriged.sim.sk[&quot;trend&quot;]) plot(co2.kriged.sim.sk[&quot;detrended.norm&quot;]) co2.kriged.sim.sk$backtransform &lt;- st_apply(co2.kriged.sim.sk[3], 1:3, backtr) plot(co2.kriged.sim.sk[&quot;backtransform&quot;]) mapview(co2.kriged.sim.sk[4,,,1]) mapview(co2.kriged.sim.sk[4,,,2]) mapview(co2.kriged.sim.sk[4,,,3]) mapview(co2.kriged.sim.sk[4,,,4]) # total CO2 flux estimate (in grams) from simulations sum(co2.kriged.sim.sk[4,,,1]$backtransform, na.rm = T) ## [1] -12.14128 sum(co2.kriged.sim.sk[4,,,2]$backtransform, na.rm = T) ## [1] 256.8621 sum(co2.kriged.sim.sk[4,,,3]$backtransform, na.rm = T) ## [1] -197.6414 sum(co2.kriged.sim.sk[4,,,4]$backtransform, na.rm = T) ## [1] 0.2366164 # total CO2 flux estimate using only the mean of measured data values st_area(pick) %&gt;% as.numeric()*mean(test_data$flux_co2_g_hr) ## [1] 702.4269 "],["diffusive-analysis.html", "Chapter 5 Diffusive analysis 5.1 Catfish Cloud Comparison 5.2 Deans Cloud Comparison", " Chapter 5 Diffusive analysis 5.1 Catfish Cloud Comparison catfish_pts_06 %&gt;% mutate(date = &quot;9/6-9/7&quot;) %&gt;% bind_rows(catfish_pts_18 %&gt;% mutate(date = &quot;9/18-9/19&quot;)) %&gt;% group_by(date, trip) %&gt;% summarize(mean_co2 = mean(flux_co2_g_hr)) %&gt;% ggplot(aes(trip, mean_co2, color = date))+geom_line() ## `summarise()` has grouped output by &#39;date&#39;. You can override using the `.groups` ## argument. 5.2 Deans Cloud Comparison deans_pts_16 %&gt;% mutate(date = &quot;8/16-8/17&quot;) %&gt;% bind_rows(deans_pts_30 %&gt;% mutate(date = &quot;8/30-8/31&quot;)) %&gt;% group_by(date, trip) %&gt;% summarize(mean_co2 = mean(flux_co2_g_hr)) %&gt;% ggplot(aes(trip, mean_co2, color = date))+geom_line() ## `summarise()` has grouped output by &#39;date&#39;. You can override using the `.groups` ## argument. catfish_pts_06 %&gt;% mutate(date = &quot;9/6-9/7&quot;) %&gt;% bind_rows(catfish_pts_18 %&gt;% mutate(date = &quot;9/18-9/19&quot;)) %&gt;% group_by(date, trip) %&gt;% summarize(mean_ch4 = mean(flux_ch4_g_hr)) %&gt;% ggplot(aes(trip, mean_ch4, color = date))+geom_line() ## `summarise()` has grouped output by &#39;date&#39;. You can override using the `.groups` ## argument. catfish_pts_06 %&gt;% mutate(date = &quot;9/6-9/7&quot;) %&gt;% bind_rows(catfish_pts_18 %&gt;% mutate(date = &quot;9/18-9/19&quot;)) %&gt;% group_by(date, trip) %&gt;% summarize(med_ch4 = median(flux_ch4_g_hr)) %&gt;% ggplot(aes(trip, med_ch4, color = date))+geom_line() ## `summarise()` has grouped output by &#39;date&#39;. You can override using the `.groups` ## argument. deans_pts_16 %&gt;% mutate(date = &quot;8/16-8/17&quot;) %&gt;% bind_rows(deans_pts_30 %&gt;% mutate(date = &quot;8/30-8/31&quot;)) %&gt;% group_by(date, trip) %&gt;% summarize(mean_ch4 = mean(flux_ch4_g_hr)) %&gt;% ggplot(aes(trip, mean_ch4, color = date))+geom_line() ## `summarise()` has grouped output by &#39;date&#39;. You can override using the `.groups` ## argument. "],["ebullition-analysis.html", "Chapter 6 Ebullition Analysis", " Chapter 6 Ebullition Analysis library(lme4) ## Loading required package: Matrix ## ## Attaching package: &#39;Matrix&#39; ## The following objects are masked from &#39;package:tidyr&#39;: ## ## expand, pack, unpack # random slope and intercept for Site, random intercept for time period? "]]
